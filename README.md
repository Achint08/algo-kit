# Basic Data Structures in different languages

## Central idea behind this project

The idea is to focus on implementing basic important data structures and algorithms on very basic problems. These data structures are not exhaustive, but these are the algorithms that we occasionally come across.
This would help in two ways:

- Learn the exact insights and mechanisms about algorithms by heart.
- Developing Template for the common data structures and algorithms for later reuse.

## List of data structures and algorithms

- [x] Insertion Sort
- [x] Merge Sort/(Two Pointers) Pointer-1 and pointer-2 from two sequences
- [x] Bubble Sort
- [x] Selection Sort
- [x] Quick Sort
- [x] Counting Sort
- [x] Binary Search/ (Two Pointers) Left and right boundary
- [x] Linked List
- [x] Doubly Linked List
- [x] Circular Linked List
- [x] Heap/Priority Queue
- [x] (Two Pointers) Floyd's Algorithm (The Tortoise and the Hare)
- [x] (Two Pointers) Old and new state
- [x] (Two Pointers) Start and end of sliding window
- [ ] Breadth First Search
- [ ] Depth First Search
- [ ] Hash Table
- [ ] Binary Search(using bisect)
- [ ] Recursion example
- [ ] Prim's Algorithm
- [ ] Krushkal's Algorithm
- [ ] Eular Path and Circuit
- [ ] Set Algorithm example
- [ ] Greedy Algorithm Knapsack
- [ ] Dynamic Programming Top down DP
- [ ] Minumum Spanning Tree
- [ ] Euclidian Circuit
- [ ] Dijkstra's Algorithm
- [ ] Floyd Warshall Algorithm
- [ ] Inorder Traversal
- [ ] Graph Representations
- [ ] Bellman Ford Algoritm
- [ ] Topological Sort
- [ ] Order Statistics
- [ ] Detecting Cycle in graph
- [ ] Directed Graph
- [ ] Undirected Graph
- [ ] Disjoint Set
- [ ] Backtracking
- [ ] Preorder Traversal
- [ ] Postorder Traversal
- [ ] Level Order Traversal
- [ ] Stack
- [ ] Queue
- [ ] Trie
- [ ] Bottom Up DP
- [ ] String Matching
- [ ] Strongly connected components
- [ ] Chinese remainder theorm
- [ ] Greatest common divisor
- [ ] Divide and Conquer
- [ ] Binary Search Tree
- [ ] Segment Tree
- [ ] Sieve of Eratosthenes
- [ ] Monotonically decreasing stack

## List of languages

1. Python

## Key insights

1. Pass by reference for Array
2. In // operation used on array length, right always get the major elements.
3. Use truth table to avoid mistakes

## Suggestions

Are there any other algorithm that I might be missing? Please open a pull request and contribute! Let's learn together.

## Input size and time complexity reference

| Input size      | Target time complexity           |
| --------------- | -------------------------------- |
| n ≤ 12          | O(n!)                            |
| n ≤ 25          | O(2^n)                           |
| n ≤ 100         | O(n^4)                           |
| n ≤ 500         | O(n^3)                           |
| n ≤ 10 000      | O(n^2)                           |
| n ≤ 1 000 000   | O(n log n)                       |
| n ≤ 100 000 000 | O(n)                             |
| n > 100 000 000 | O(1) or O(log n) or O(n ^ (1/2)) |

## References

- https://www.programiz.com/
- https://www.geeksforgeeks.org/
- https://codeforces.com/blog/entry/21344
- https://www.pluralsight.com/guides/algorithm-templates:-introduction
- https://leetcode.com/problems/sum-of-subarray-minimums/discuss/178876/stack-solution-with-very-detailed-explanation-step-by-step

## Thank You. :)
